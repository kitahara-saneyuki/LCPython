# System Design 系统设计

## RDBMS Design NF 数据库设计范式

### 1NF: 关系中的每个属性都不可再分。

### 2NF: 消除了非主属性对于码的部分函数依赖。

1. 函数依赖：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。
   1. 例：姓名函数依赖于学号，写作 学号 → 姓名。
   2. 完全函数依赖：在一张表中，若 X → Y，且对于 X 的任何一个真子集 X'（假如属性组 X 包含超过一个属性的话），X' → Y 不成立，那么我们称 Y 对于 X 完全函数依赖
   3. 部分函数依赖：假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X
   4. 码：假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。
2. 非主属性：包含在任何一个码中的属性成为主属性。
3. 操作过程：
   1. 找出数据表中所有的码。
   2. 根据第一步所得到的码，找出所有的主属性。
   3. 数据表中，除去所有的主属性，剩下的就都是非主属性了。
   4. 查看是否存在非主属性对码的部分函数依赖。

### 3NF: 在2NF的基础之上，消除了非主属性对于码的传递函数依赖。

1. 传递函数依赖：假如 Z 函数依赖于 Y，且 Y 函数依赖于 X，那么我们就称 Z 传递函数依赖于 X。

## 系统设计的套路：

1. 重在讨论和交流，厘清一切限制条件，然后在这些限制条件下面找到一个比较合理的解决方案。
2. 先描述一个大的设计框架，works for small scale
3. 给出更多的details，满足面试官的更高要求
4. 主要看中的是你思考论述的过程
   1. 对不同方面瓶颈的分析
   2. 对不同解决方案的估测
   3. 性能：Latency延迟 & Throughput吞吐量
      1. 内存随机访问：0.1 us
      2. SSD随机访问：150 us
      3. 通常，你应该以可接受级延迟下最大化吞吐量为目标。
   4. 可用性和可靠性，成本
   5. 可扩展性：如果服务性能的增长与资源的增加是成比例的，服务就是可扩展的。
5. 各种套路
   1. Cache：缓存
   2. Asynchronized & Queue：批处理＋异步和消息队列
   3. Load Balance：负载均衡
   4. Reverse Proxy：反向代理
   5. RDBMS & noSQL：Replication & Partition 数据库系统冗余和分片
   6. Platform Server：Web 服务层与应用层（也被称作平台层）分离
   7. Availablity：可用性

## 系统设计的工具：

### 1. Cache：缓存

缓存可以提高页面加载速度，并可以减少服务器和数据库的负载。在这个模型中，分发器先查看请求之前是否被响应过，如果有则将之前的结果直接返回，来省掉真正的处理。

数据库分片均匀分布的读取是最好的。但是热门数据会让读取分布不均匀，这样就会造成瓶颈，如果在数据库前加个缓存，就会抹平不均匀的负载和突发流量对数据库的影响。

基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如 least recently used (LRU) 的缓存无效算法可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。

#### 缓存更新模式：缓存模式

1. 在缓存中查找记录
2. 如果所需数据不在缓存中，从数据库中加载所需内容
3. 将查找到的结果存储到缓存中
4. 返回所需内容
5. 缺陷：
   1. 请求的数据如果不在缓存中就需要经过三个步骤来获取数据，这会导致明显的延迟。
   2. 如果数据库中的数据更新了会导致缓存中的数据过时。这个问题需要通过设置强制更新缓存或者直写模式来缓解这种情况。
   3. 当一个节点出现故障的时候，它将会被一个新的节点替代，这增加了延迟的时间。

#### 缓存更新模式：直写模式

1. 应用向缓存中添加/更新数据
2. 缓存同步地写入数据存储
3. 返回所需内容
4. 缺陷：
   1. 由于故障或者缩放而创建的新的节点，新的节点不会缓存，直到数据库更新为止。缓存应用直写模式可以缓解这个问题。
   2. 写入的大多数数据可能永远都不会被读取，用 TTL 可以最小化这种情况的出现。

#### 缓存更新模式：回写模式

1. 在缓存中增加或者更新条目
2. 异步写入数据，提高写入性能。
3. 缺陷：
   1. 缓存可能在其内容成功存储之前丢失数据。
   2. 执行直写模式比缓存或者回写模式更复杂。

### 2. Asynchronized & Queue：批处理＋异步和消息队列

消息队列接收，保留和传递消息。如果按顺序执行操作太慢的话，你可以使用有以下工作流的消息队列：

1. 应用程序将作业发布到队列，然后通知用户作业状态
2. 一个 worker 从队列中取出该作业，对其进行处理，然后显示该作业完成

不去阻塞用户操作，作业在后台处理。在此期间，客户端可能会进行一些处理使得看上去像是任务已经完成了。例如，如果要发送一条推文，推文可能会马上出现在你的时间线上，但是可能需要一些时间才能将你的推文推送到你的所有关注者那里去。

任务队列接收任务及其相关数据，运行它们，然后传递其结果。它们可以支持调度，并可用于在后台运行计算密集型作业。

### 3. Load Balance：负载均衡

负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器还能帮助水平扩展，提高性能和可用性。负载均衡器可以：

1. 防止请求进入不好的服务器
2. 防止资源过载
3. 帮助消除单一的故障点

可用性 availability 分析：通常会设置采用 工作─备用 或 双工作 模式的多个负载均衡器，以免发生故障。

负载均衡器能基于多种方式来路由流量：随机、最少负载、Session/cookie、轮询调度或加权轮询调度算法

### 4. Reverse Proxy：反向代理

反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。

优势：

1. 增加安全性 - 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。
2. 提高可扩展性和灵活性 - 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。
3. 本地终结 SSL 会话 - 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。
4. 压缩 - 压缩服务器响应
5. 缓存 - 直接返回命中的缓存结果
6. 静态内容 - 直接提供静态内容

### 5. RDBMS & noSQL：Replication & Partition 冗余和分片

1. 冗余：主从复制：主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。
   1. 应对环境：多读而少写的情况
2. 分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。
3. 索引通常表示为自平衡的B树，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。写入操作会变慢，因为索引需要被更新。

### 6. Platform Server：Web 服务层与应用层（也被称作平台层）分离

将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。添加新的 API 只需要添加应用服务器，而不必添加额外的 web 服务器。

单一职责原则提倡小型的，自治的服务共同合作。小团队通过提供小型的服务，可以更激进地计划增长。

应用层中的工作进程也有可以实现异步化。

### 7. Availablity：可用性

1. 工作到备用切换（Active-passive）：关于工作到备用的故障切换流程是，工作服务器发送周期信号给待机中的备用服务器。如果周期信号中断，备用服务器切换成工作服务器的 IP 地址并恢复服务。只有工作服务器处理流量。工作到备用的故障切换也被称为主从切换。
2. 双工作切换（Active-active）：在双工作切换中，双方都在管控流量，在它们之间分散负载。双工作切换也可以称为主主切换。

## 实际问题：

### 简单题：用户密码的存储：加入随机 salt 的哈希算法

密码原文（或经过 hash 后的值）和随机生成的 salt 字符串混淆，然后再进行 hash，最后把 hash 值和 salt 值一起存储。验证密码的时候只要用 salt 再与密码原文做一次相同步骤的运算，比较结果与存储的 hash 值就可以了。这样一来哪怕是简单的密码，在进过 salt 混淆后产生的也是很不常见的字符串，根本不会出现在彩虹字典中。salt 越长暴力破解的难度越大。这样不可能得到密码的明文，就算是系统管理员也没办法。对于那些真的忘了密码的用户，网站只能提供重置密码的功能了。

### 简单题：短URL系统

1. 小规模能用：每一个过来的长地址，发一个号，用mysql的自增索引
2. 大并发高可用：1000个逻辑发号器，分别发尾号为0到999的号。每发一个号，每个发号器加1000，而不是加1。这些发号器独立工作，互不干扰，用负载平衡给他们分派任务即可。
3. 跳转用301还是302？301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。同时对服务器压力也会有一定减少。但是如果使用了301，我们就无法统计到短地址被点击的次数了。而这个点击次数是一个非常有意思的大数据分析数据源。能够分析出的东西非常非常多。所以选择302虽然会增加服务器压力，但是我想是一个更好的选择。
